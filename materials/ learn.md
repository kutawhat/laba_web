

```js
import { Module } from'@nestjs/common';

@Module({
    controllers: [],
    providers: [],
})

export class AuthorsModule {}
```

Измененный файл app.module.ts
```ts
import { Module } from'@nestjs/common';
import { AuthorsModule } from'./authors/authors.module';

@Module({
    imports: [AuthorsModule],
    controllers: [],
    providers: [],
})

export class AppModule {}
```


## Создание модели:

В папке authors создадим файл author.entity.ts. Это наша первая модель, теперь необходимо прописать для нее свойства.

```ts
export class Author {
    id:number;
    fullname:string;
    position:string;
    grade:string;
}
```

Данная модель предусматривает, что она обладает конечным набором свойств, описывающих экземпляр сущности.

И также импортируем в модуль авторов только что созданную модель, чтобы модуль идентифицировал наш класс Author как модель.

```js
import { Module } from'@nestjs/common';
import { Author } from'./entities/author.entity';

@Module({
    controllers: [],
    providers: [],
    imports: [Author],
})

export class AuthorsModule {}
```

## Создание источника данных:

В рамках лабораторной работы №2 будем использовать псевдобазу данных на основе класса со списком авторов.

В других языках это можно было бы реализовать при помощи антипаттерна Singleton. Однако в nestjs мы создадим для этого отдельный модуль с сервисом, в котором и будем хранить наш список с авторами.

В файле модуля мы создадим класс, в котором будет храниться пустой массив авторов, который будем использовать в других сервисах. Важно то, что нам всегда будет возвращаться не новый экземпляр массива, а каждый раз один и тот же массив авторов.

В сервисе, помимо массива, необходимо реализовать метод доступа к классу авторов.

Наполнение файла datasource.service.ts
```js
import { Injectable } from'@nestjs/common';
import { Author } from'src/authors/entities/author.entity';

@Injectable()
export class DatasourceService {
    private authors:Author[] = [];

    getAuthors() : Author[] {
        return this.authors;
}
}
```

Теперь нам необходимо сообщить модулю, что у него есть сервис, которым мы можем делиться с другими модулями для доступа к импровизированной базе данных.

Наполнение файла datasource.module.ts

```js
import { Module } from'@nestjs/common';

import { DatasourceService } from'./datasource.service';

@Module({
    providers: [DatasourceService], _// тут мы указали что у нас есть сервис внутри модуля_
    exports: [DatasourceService], _// здесь мы разрешаем экспортировать сервис в другие модули_
})
export class DatasourceModule {}
```

## Создание сервиса:

**Сервис - это класс - обработчик высоконагруженных операций. В сервис обычно выносится асинхронная логика взаимодействия с базой данных и любыми операциями с данными.**

Создадим сервис для сущности Автор. В папке authors создадим файл authros.service.ts

```js
@Injectable()
export class AuthorsService {}
```

Это пустой класс, который пока не умеет ничего обрабатывать. Над ним указана аннотация, которая говорит нам о возможности применения такого подхода, как DependencyInjection. Но, подробнее об этом понятии мы поговорим чуть позже.

Теперь, нам необходимо создать конструктор класса сервиса и в нем объявить сервис псевдо-базы данных. Внутри класса объявим конструктор и пропишем параметром сервис псевдо-базы данных.

```js
constructor(private readonly datasourceService: DatasourceService) {}
```

Создадим методы обработки сущности автор внутри сервиса. При обращении к методам будет возвращаться только тот результат, что декларирован методами обработки и преобразования списка авторов.

Создадим метод добавления автора:
```js
create(author:Author) {
    this.datasourceService.getAuthors().push(author);

    return author;
}
```

Данный метод принимает в качестве аргумента экземпляр автора и добавляет его в коллекцию существующих авторов.

Метод для получения автора по ID:
```js
findOne(id:number) {
    return this.datasourceService
        .getAuthors()
        .find((author) =\>author.id ===id);

}
```

Метод для получения всех авторов:

```js
findAll() : Author[] {
    return this.datasourceService.getAuthors();
}
```

Метод изменения автора:

```js
update(id:number, updatedAuthor:Author) {
    const index =this.datasourceService
        .getAuthors()
        .findIndex((author) =\>author.id ===id);

    this.datasourceService.getAuthors()[index] =updatedAuthor;
    return this.datasourceService.getAuthors()[index];
}
```
Метод удаления автора:
```js
remove(id:number) {
    const index =this.datasourceService
        .getAuthors()
        .findIndex((author) =\>author.id ===id);
    
    this.datasourceService.getAuthors().splice(index, 1);

    return HttpStatus.OK;
}
```

На данном этапе у нас написана базовая реализация основных операций с данными. Данные операции называются CRUD(Create, Read, Update, Delete).Исходя из этого, у нас есть готовый инструментарий декларированного доступа к коллекции авторов для внешних источников. Таких, как контроллер.


## Создание контроллера:

**Контроллер - это точка обращения на сервер. В методах происходит обработка начального запроса в зависимости от типа.**

Создадим контроллер для сущности Автор. В папке authors создадим файл authors.controller.ts

```js
import { AuthorsService } from'./authors.service';
import { Controller} from'@nestjs/common';

@Controller('authors')
export class AuthorsController {
    constructor(privatereadonlyauthorsService:AuthorsService) {}
}
```

На данный момент это пустой контроллер с указанным маршрутом для доступа. В качестве зависимости(параметра конструктора) выступает созданный ранее сервис авторов. Теперь создадим первый обработчик запроса.

Самый простой и распространенный тип запроса - это Get запрос. Благодаря Get запросу мы можем запросить данные от сервера по пути контроллера. В данном случае - это путь localhost:3001/api/author

<hr>
**Get запрос на получение авторов:**

```js
@Get()
    findAll() {
        return this.authorsService.findAll();
}
```

При Get запросе по пути localhost:3001/api/author сервер вернет всех доступных авторов.


**Get запрос на получение автора по ID**

```js
@Get(':id')
    findOne(@Param('id') id:string) {
        return this.authorsService.findOne(+id);
}
```

При Get запросе по пути localhost:3001/api/author/{числовое значение - идентификатор} сервер вернет автора с указанным ID.


**PUT запрос на изменение автора**

```js
@Put(':id')
    update(@Param('id') id:string, @Body() updateAuthor:Author) {
        return this.authorsService.update(+id, updateAuthor);
}
```

При PUT запросе по пути localhost:3001/api/author/{числовое значение - идентификатор} и с объектом типа Author в теле запроса сервер применит новые значения для автора, если найдёт его в источнике данных и вернет обновленный экземпляр сущности.


**POST запрос на добавление автора**

```js
@Post()
    create(@Body() createAuthor:Author) {
    return this.authorsService.create(createAuthor);
}
```

При POST запросе по пути localhost:3001/api/author с объектом типа Author в теле запроса сервер добавит в источник данных новый экземпляр сущности автор.


**DELETE запрос на удаление автора**

```js
@Delete(':id')
    remove(@Param('id') id:string) {
        return this.authorsService.remove(+id);
}
```

При DELETE запросе по пути localhost:3001/api/author/{числовое значение - идентификатор} сервер удалит автора с указанным в запросе ID, если такой будет в источнике данных.
<hr>


## HTTP. Структура сообщения

Каждое HTTP-сообщение состоит из трёх частей, которые передаются в указанном порядке:
- **Стартовая строка** (англ. Starting line) — определяет тип сообщения;
- **Заголовки** (англ. Headers) — характеризуют тело сообщения, параметры передачи и прочие сведения;
- **Тело сообщения** (англ. Message Body) — непосредственно данные сообщения. Обязательно должно отделяться от заголовков пустой строкой.

Заголовки и тело сообщения могут отсутствовать, но стартовая строка является обязательным элементом, так как указывает на тип запроса/ответа. Исключением является версия 0.9 протокола, у которой сообщение запроса содержит только стартовую строку, а сообщения ответа только тело сообщения.
<hr>


## HTTP. Методы

**GET**
Метод GET запрашивает представление ресурса. Запросы с использованием этого метода могут только извлекать данные.

**HEAD**
HEAD запрашивает ресурс так же, как и метод GET, но без тела ответа.

**POST**
POST используется для отправки сущностей к определённому ресурсу. Часто вызывает изменение состояния или какие-то побочные эффекты на сервере.

**PUT**
PUT заменяет все текущие представления ресурса данными запроса.

**DELETE**
DELETE удаляет указанный ресурс.

**CONNECT**
CONNECT устанавливает "туннель" к серверу, определённому по ресурсу.

**OPTIONS**
OPTIONS используется для описания параметров соединения с ресурсом.

**TRACE**
TRACE выполняет вызов возвращаемого тестового сообщения с ресурса.

**PATCH**
PATCH используется для частичного изменения ресурса.
<hr>


## HTTP. Коды ответов сервера

**1xx Informational («Информационный»)**
В этот класс выделены коды, информирующие о процессе передачи. В HTTP/1.0 сообщения с такими кодами должны игнорироваться. В HTTP/1.1 клиент должен быть готов принять этот класс сообщений как обычный ответ, но ничего отправлять серверу не нужно. Сами сообщения от сервера содержат только стартовую строку ответа и, если требуется, несколько специфичных для ответа полей заголовка. Прокси-серверы подобные сообщения должны отправлять дальше от сервера к клиенту.

**2xx Success («Успех»)**
Сообщения данного класса информируют о случаях успешного принятия и обработки запроса клиента. В зависимости от статуса сервер может ещё передать заголовки и тело сообщения.

**3xx Redirection («Перенаправление»)**
Коды класса 3xx сообщают клиенту что для успешного выполнения операции необходимо сделать другой запрос (как правило по другому URI). Из данного класса пять кодов 301, 302, 303, 305 и 307 относятся непосредственно к перенаправлениям (редирект). Адрес, по которому клиенту следует произвести запрос, сервер указывает в заголовке Location. При этом допускается использование фрагментов в целевом URI.

**4xx Client Error («Ошибка клиента»)**
Класс кодов 4xx предназначен для указания ошибок со стороны клиента. При использовании всех методов, кроме HEAD, сервер должен вернуть в теле сообщения гипертекстовое пояснение для пользователя.

**5xx Server Error («Ошибка сервера»)**
Коды 5xx выделены под случаи неудачного выполнения операции по вине сервера. Для всех ситуаций, кроме использования метода HEAD, сервер должен включать в тело сообщения объяснение которое клиент отобразит пользователю.
<hr>


## HTTP. Заголовки

**HTTP Headers** — это строки в HTTP-сообщении, содержащие разделенную двоеточием пару параметр-значение. Формат заголовков соответствует общему формату
заголовков текстовых сетевых сообщений ARPA (RFC 822). Заголовки должны
отделяться от тела сообщения хотя бы одной пустой строкой!
Все заголовки разделяются на четыре основных группы:

• **General Headers** («Основные заголовки») — могут включаться в любое сообщение клиента и сервера.

• **Request Headers** («Заголовки запроса») — используются только в запросах клиента.

• **Response Headers** («Заголовки ответа») — только для ответов от сервера.

• **Entity Headers** («Заголовки сущности») — сопровождают каждую сущность сообщения.
<hr>


## Коды состояния
HTTP/1.1 200 OK
HTTP/1.1 201 Created
HTTP/1.1 204 No Content
HTTP/1.1 304 Not Modified
HTTP/1.1 400 Bad Request
HTTP/1.1 404 Not Found
HTTP/1.1 503 Service Unavailable